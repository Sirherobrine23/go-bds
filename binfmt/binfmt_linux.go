//go:build linux || android

// Check if qemu or box64/box86 enabled in binfmt or ared exists in PATH's
package binfmt

import (
	"bufio"
	"bytes"
	"encoding/hex"
	"fmt"
	"io"
	"io/fs"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
)

var (
	_ Binfmt = &linuxFmt{}

	lineSplit = regexp.MustCompile(`(\s|\t)+`)

	archsHeaders = map[string]struct{ Magic, Mask []byte }{
		"x86_64":       {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x3e, 0x0}, []byte{0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbe, 0xc3, 0xbe, 0x0, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbe, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf}},
		"i386":         {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x3, 0x0}, []byte{0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbe, 0xc3, 0xbe, 0x0, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbe, 0xc3, 0xbf, 0xc3, 0xbf, 0xc3, 0xbf}},
		"aarch64":      {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0xb7, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"aarch64_be":   {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0xb7}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"arm":          {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x28, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"armeb":        {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x28}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"alpha":        {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x26, 0x90}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"hexagon":      {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0xa4, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"hppa":         {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0xf}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"loongarch64":  {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x2, 0x1}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"m68k":         {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x4}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"microblaze":   {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0xba, 0xab}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"microblazeel": {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0xab, 0xba}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"mips":         {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x8, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20}},
		"mips64":       {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x8}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"mips64el":     {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x8, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"mipsel":       {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x8, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0}},
		"mipsn32":      {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x8, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20}},
		"mipsn32el":    {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x8, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0}},
		"or1k":         {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x5c}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"ppc":          {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x14}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"ppc64":        {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x15}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"ppc64le":      {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x15, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0x0}},
		"riscv32":      {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0xf3, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"riscv64":      {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0xf3, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"s390x":        {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x16}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"sh4":          {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x2a, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"sh4eb":        {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x2a}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"sparc":        {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x2}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"sparc32plus":  {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x12}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"sparc64":      {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x2, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x2b}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
		"xtensa":       {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x5e, 0x0}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff}},
		"xtensaeb":     {[]byte{0x7f, 0x45, 0x4c, 0x46, 0x1, 0x2, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x5e}, []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff}},
	}
)

const (
	FlagUnknown   = linuxFmtFlag(iota) // Unknown flag
	FlagFixBinary                      // Fix binary path
	FlagCredentials
	FlagOpenBinary
	FlagPreserveargv
)

type linuxFmtFlag uint

type linuxFmt struct {
	AutoEmulate bool   // System auto select emulater
	Interpreter string // binary path
	stringArch  string // Binary target
	sSys        string
	Offset      int
	Flags       linuxFmtFlag
	Magic       []byte
	Mask        []byte

	LocalFile string
}

func (linuxBinfmt linuxFmt) String() string {
	return fmt.Sprintf("%s/%s", linuxBinfmt.sSys, linuxBinfmt.stringArch)
}

func (fmt linuxFmt) SystemSelect() bool    { return fmt.AutoEmulate }
func (fmt linuxFmt) ProgramArgs() []string { return []string{fmt.Interpreter} }
func (fmt linuxFmt) Sys() string {
	if fmt.sSys == "" {
		return "linux"
	}
	return fmt.sSys
}

func (fmt linuxFmt) Arch() string {
	switch fmt.stringArch {
	case "arm64", "aarch64_be":
		return "arm64"
	case "armeb":
		return "arm"
	case "x86_64":
		return "amd64"
	case "i386":
		return "386"
	default:
		return fmt.stringArch
	}
}

func (fmt linuxFmt) Check(r io.ReadSeeker) error {
	if fmt.Offset > 0 {
		if _, err := r.Seek(int64(fmt.Offset), io.SeekStart); err != nil {
			return err
		}
	}

	fistBytes := make([]byte, len(fmt.Magic))
	if _, err := r.Read(fistBytes); err != nil {
		return err
	} else if !bytes.Contains(fistBytes, fmt.Magic) {
		return ErrNoSupportedPlatform
	}
	return nil
}

func (flag linuxFmtFlag) String() string {
	switch flag {
	case FlagFixBinary:
		return "fix-binary"
	case FlagCredentials:
		return "credentials"
	case FlagOpenBinary:
		return "open-binary"
	case FlagPreserveargv:
		return "preserve-argv[0]"
	default:
		return "Unknown"
	}
}
func (flag linuxFmtFlag) Flags() []string {
	var flags []string

	attemps := 5
	for flag > 0 && attemps > 0 {
		switch {
		case FlagFixBinary&flag != 0:
			flags = append(flags, FlagFixBinary.String())
			flag &= FlagFixBinary
		case FlagCredentials&flag != 0:
			flags = append(flags, FlagCredentials.String())
			flag &= FlagCredentials
		case FlagOpenBinary&flag != 0:
			flags = append(flags, FlagOpenBinary.String())
			flag &= FlagOpenBinary
		case FlagPreserveargv&flag != 0:
			flags = append(flags, FlagPreserveargv.String())
			flag &= FlagPreserveargv
		default:
			attemps--
		}
	}
	return flags
}

func preapend[T any](input []T, rest ...T) []T {
	return append(rest, input...)
}

// List archs registred
func Archs() ([]Binfmt, error) {
	var arch []Binfmt
	entrys, err := os.ReadDir("/proc/sys/fs/binfmt_misc")
	if err != nil {
		if !(os.IsNotExist(err) || os.IsPermission(err)) {
			return nil, err
		}
		entrys = []fs.DirEntry{}
	}

	for _, file := range entrys {
		fileName := file.Name()
		if fileName == "status" || fileName == "register" {
			continue
		}

		qemuFmt, err := os.OpenFile(filepath.Join("/proc/sys/fs/binfmt_misc", fileName), os.O_RDONLY, 0)
		if err != nil {
			continue
		}
		defer qemuFmt.Close()

		var bin linuxFmt
		if bin.LocalFile = fileName; strings.HasPrefix(fileName, "windows") {
			bin.sSys = "windows"
		}

		b := bufio.NewScanner(qemuFmt)
		for b.Scan() {
			line := lineSplit.Split(b.Text(), 2)

			switch strings.TrimSpace(line[0]) {
			case "enabled":
				bin.AutoEmulate = true
			case "interpreter":
				bin.Interpreter = strings.TrimSpace(line[1])
				if strings.Contains(bin.Interpreter, "/wine") {
					bin.sSys = "windows"
				}
			case "flags:":
				bin.Flags = 0
				if line[1] != "" {
					for _, letter := range strings.Split(line[1], "") {
						switch strings.ToUpper(letter) {
						case "F", "f":
							bin.Flags |= FlagFixBinary
						case "C", "c":
							bin.Flags |= FlagCredentials
						case "O", "o":
							bin.Flags |= FlagOpenBinary
						case "P", "p":
							bin.Flags |= FlagPreserveargv
						}
					}
				}
			case "offset":
				if _, err := fmt.Sscan(strings.TrimSpace(line[1]), &bin.Offset); err != nil {
					return arch, err
				}
			case "magic":
				if bin.Magic, err = hex.DecodeString(strings.TrimSpace(line[1])); err != nil {
					return arch, err
				}
			case "mask":
				if bin.Mask, err = hex.DecodeString(strings.TrimSpace(line[1])); err != nil {
					return arch, err
				}
			}
		}

		for arch, info := range archsHeaders {
			if bytes.Equal(info.Magic, bin.Magic) && bytes.Equal(info.Mask, bin.Mask) {
				bin.stringArch = arch
				break
			}
		}
		arch = append(arch, &bin)
	}

	if len(arch) == 0 {
		for Arch, qemuArch := range archsHeaders {
			var qemuPath string
			if qemuPath, _ = exec.LookPath(fmt.Sprintf("qemu-%s-static", Arch)); len(qemuPath) == 0 {
				if qemuPath, _ = exec.LookPath(fmt.Sprintf("qemu-%s", Arch)); len(qemuPath) == 0 {
					continue
				}
			}
			arch = append(arch, &linuxFmt{stringArch: Arch, Interpreter: qemuPath, Magic: qemuArch.Magic, Mask: qemuArch.Mask})
		}

		// Add termux glibc repository bin
		if _, err := os.Stat(filepath.Join(os.Getenv("PREFIX"), "glibc/bin")); !os.IsNotExist(err) {
			if !strings.Contains(os.Getenv("PATH"), "glibc/bin") {
				os.Setenv("PATH", strings.Join([]string{filepath.Join(os.Getenv("PREFIX"), "glibc/bin"), os.Getenv("PATH")}, ":"))
			}
		}
	}

	// Box64 emulater
	if box86, _ := exec.LookPath("box86"); box86 != "" {
		arch = preapend(arch, Binfmt(&linuxFmt{
			stringArch:  "i386",
			Interpreter: box86,
			Magic:       archsHeaders["i386"].Magic,
			Mask:        archsHeaders["i386"].Mask,
		}))
	}
	if box64, _ := exec.LookPath("box64"); box64 != "" {
		arch = preapend(arch, Binfmt(&linuxFmt{
			stringArch:  "x86_64",
			Interpreter: box64,
			Magic:       archsHeaders["x86_64"].Magic,
			Mask:        archsHeaders["x86_64"].Mask,
		}))
	}

	return arch, nil
}
